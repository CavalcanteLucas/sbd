As instruções de inserção, exclusão e atualização modificam o banco de dados permanentemente (são operações não-idempotentes). Por isso, é importante verificar o estado dos dados antes de e após executar esse tipo de instrução.

Com isso, queremos de evitar a todo custo a situação em que
devemos restaurar o banco de dados a uma versão anterior. Esse tipo de operação pode ser muito custosa para um SBD em produção. Sobretudo, há uma potencial perda de informações para atualizações realizadas entre a data do último backup e o completo re-estabelecimento do serviço.

No entanto, em última instância, utilize as seguintes instruções para restaurar o banco:
```
PGPASSWORD=1234 psql -h localhost -p 5432 -U postgres -d postgres -f lab/DDL+drop.sql
PGPASSWORD=1234 psql -h localhost -p 5432 -U postgres -d postgres -f lab/smallRelationsInsertFile.sql
```

## 3.03 - a)

```
SELECT *
FROM instructor
WHERE dept_name = 'Comp. Sci.'
```

| id    | name       | dept_name  | salary   |
| ----- | ---------- | ---------- | -------- |
| 10101 | Srinivasan | Comp. Sci. | 65000.00 |
| 45565 | Katz       | Comp. Sci. | 75000.00 |
| 83821 | Brandt     | Comp. Sci. | 92000.00 |

```
UPDATE instructor
SET salary = salary * 1.1
WHERE dept_name = 'Comp. Sci.'
```

```
SELECT *
FROM instructor
WHERE dept_name = 'Comp. Sci.'
```

| id    | name       | dept_name  | salary    |
| ----- | ---------- | ---------- | --------- |
| 10101 | Srinivasan | Comp. Sci. | 71500.00  |
| 45565 | Katz       | Comp. Sci. | 82500.00  |
| 83821 | Brandt     | Comp. Sci. | 101200.00 |

## 3.03 - b)

Vejamos quais cursos atendem a essa condição:
```
select course_id from course where course_id not in (
  select course_id from section
)
```

| course_id |
| --------- |
| BIO-399   |

Podemos deletá-los de `course` da seguinte maneira:
```
delete from course
where course_id not in (
  select course_id from section
)
```

Agora a query
```
select course_id from course where course_id not in (
  select course_id from section
)
```
deve retornar um conjunto vazio.

## 3.03 - c)

Podemos selecionar tais alunos:
```
SELECT *
FROM student
WHERE tot_cred > 100
```

| id    | name   | dept_name  | tot_cred |
| ----- | ------ | ---------- | -------- |
| 00128 | Zhang  | Comp. Sci. | 102      |
| 23121 | Chavez | Finance    | 110      |
| 98988 | Tanaka | Biology    | 120      |

No entanto, não é possível torná-los instrutores, com esses salários.

Se fizermos:
```
INSERT INTO instructor
SELECT s.id, s.name, s.dept_name, 10000.00 AS salary
  FROM student s
  WHERE tot_cred > 100
```

nos deparamos com um erro:

"""
There was a problem!

new row for relation "instructor" violates check constraint "instructor_salary_check"
You need both a title, and some query text.
"""

Podemos buscar na tabela `pg_contraint` por restrições de integridade com o nome `instructor_salary_check`:

```
SELECT conname, pg_get_constraintdef(oid)
  FROM pg_constraint
  WHERE conname LIKE 'instructor_salary_check';
```

| conname                 | pg_get_constraintdef                |
| ----------------------- | ----------------------------------- |
| instructor_salary_check | CHECK ((salary > (29000)::numeric)) |

Com isso, vemos que a tabela `instructor` possui uma restrição para garantir que nenhum instrutor possa receber menos que $29000.00.

1: https://pgpedia.info/p/pg_get_constraintdef.html
**pg_get_constraintdef**() é uma função do sistema para obter a definição de restrições; essa função foi introduzida no PostgreSQL 7.3.