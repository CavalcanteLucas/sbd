As instruções de inserção, exclusão e atualização modificam o banco de dados permanentemente (são operações não-idempotentes). Por isso, é importante verificar o estado dos dados antes de e após executar esse tipo de instrução.

Com isso, queremos de evitar a todo custo a situação em que
devemos restaurar o banco de dados a uma versão anterior. Esse tipo de operação pode ser muito custosa para um SBD em produção. Sobretudo, há uma potencial perda de informações para atualizações realizadas entre a data do último backup e o completo re-estabelecimento do serviço.

## 3.03 - a)

```
SELECT *
FROM instructor
WHERE dept_name = 'Comp. Sci.'
```

| id    | name       | dept_name  | salary   |
| ----- | ---------- | ---------- | -------- |
| 10101 | Srinivasan | Comp. Sci. | 65000.00 |
| 45565 | Katz       | Comp. Sci. | 75000.00 |
| 83821 | Brandt     | Comp. Sci. | 92000.00 |

```
UPDATE instructor
SET salary = salary * 1.1
WHERE dept_name = 'Comp. Sci.'
```

```
SELECT *
FROM instructor
WHERE dept_name = 'Comp. Sci.'
```

| id    | name       | dept_name  | salary    |
| ----- | ---------- | ---------- | --------- |
| 10101 | Srinivasan | Comp. Sci. | 71500.00  |
| 45565 | Katz       | Comp. Sci. | 82500.00  |
| 83821 | Brandt     | Comp. Sci. | 101200.00 |

## 3.03 - b)

```
SELECT * FROM course

DELETE FROM course c1
WHERE c1.curse_id in (
  SELECT c.course_id
  FROM course c
  LEFT join section s
   ON c.course_id = s.course_id
  WHERE s.course_id IS NULL
)

SELECT * FROM course
```

## 3.03 - c)

Podemos selecionar tais alunos:

```
SELECT *
FROM student
WHERE tot_cred > 100
```

No entanto, não é possível torná-los instrutores, com esses salários.
Se fizermos:

```
INSERT INTO instructor
SELECT s.id, s.name, s.dept_name, 10000.00 AS salary
  FROM student s
  WHERE tot_cred > 100
```

nos deparamos com com um erro:

"""
There was a problem!

new row for relation "instructor" violates check constraint "instructor_salary_check"
You need both a title, and some query text.
"""

Podemos investigar a tabela 'pg_contraint' para verificar que por restrições de integridade com o nome `instructor_salary_check`:

```
SELECT conname, pg_get_constraintdef(oid)
  FROM pg_constraint
  WHERE conname LIKE 'instructor_salary_check';
```

| conname                 | pg_get_constraintdef                |
| ----------------------- | ----------------------------------- |
| instructor_salary_check | CHECK ((salary > (29000)::numeric)) |

Com isso, vemos que a tabela `instructor` possui uma restrição para garantir que nenhum instrutor possa receber menos que $29000.00:

1: https://pgpedia.info/p/pg_get_constraintdef.html
**pg_get_constraintdef**() é uma função do sistema para obter a definição de restrições; essa função foi introduzida no PostgreSQL 7.3.